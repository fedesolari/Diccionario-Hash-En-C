
IMPLEMENTACION:
--------------
--------------

+ Estructura del hash:
---------------------

Defini asi la estructura del hash debido a que, en primer lugar necesito una tabla de hash que en cada celda almacene la clave , que es el ID, y una informacion, determinada por el usuario, del elemento insertado, a su vez necesito saber si esa posicion esta ocupada o no lo esta para evitar problemas de acceso a datos invalidos. Luego necesito contener dentro de la estructura un espacio para almacenar un destructor en caso de que el usuario desee o necesite darme una funcion especifica para eliminar la informacion que quiere almacenar. A su vez necesito almacenar la capacidad total de elementos que puede contener la tabla de hash  y la ocupacion de la misma que seria la cantidad de elementos ya insertados dentro de la misma. La capacidad y la ocupacion son fundamentales a la hora de saber cuando hay que rehashear.



+hash_crear-----> Reservo la memoria necesaria para almacenar toda mi estructura de hash, luego integro el destructor que me provee el usuario, sea NULL o no. Luego si el usuario desea crear una tabla de hash con una capacidad menor o igual a la capacidad minima, no se creara con la capacidad solicitada, sino que se creara con la capacidad minima predeterminada que en este caso es 3. En el caso en el que el usuario desee crear una tabla de hash con una capacidad mayor que la minima, se creara con la capacidad solicitada por el mismo.


+funcion_de_hash: eligi una funcion de hash simple y en mi opinion bastante util ya que lo que hace es tomar el valor de ASCII de cada caracter y los suma a todos. Creo que esta funcion reparte equitativamente a cada clave en un lugar distinto de la tabla de hash tratando evitar una posible colision. Siempre que llamo a la funcion de hash, luego llamo a una funcion que me modulariza el valor, es decir que me devuelve un valor entre 0 y la capacidad del hash menos 1.

+Hash_insertar------> Recibo un hash y una clave y corroboro que ninguno de ellos sea NUll, en el caso de que alguno de los dos lo sea salgo de la funcion returneando un valor predeterminado como error. Luego hasta de realizar cada insercion realizo una cuenta que me determina el factor de carga, esa cuenta lo que hace es calcular el 75% de la capacidad que fue lo que yo supuse que seria una buena cantidad de elementos almacenados para rehashear. Luego si la cantidad de de celdas ocupadas es mayor o igual a el factor de carga establecido, debo rehashear.
 
Para rehashear llamo a una funcion que lo que hace es duplicar la canpacidad de la tabla de hash actual y con esa capacidad crea una nueva tabla de hash e inserta dentro de esa nueva tabla todos las claves junto a sus elementos que se encuentran el la tabla de hash original. Sin embargo, no es una reinsercion en si, ya que en este caso no tengo que incrementar la cantidad de elementos al insertar porque es la misma que tenia antes; tampoco debo verificar que si la clave ya existe porque eso ya lo verifique cuando inserte los elementos en la tabla de hash original entonces se que eso no puede pasar. Dicho esto, omitiendo estas exepciones el inserta funciona de la misma manera, es decir que calculo mediante la funcion de hash la posicion donde deberia ser insertado el elemento, llamo a una funcion recursiva que recibe la tabla de hash, dicha posicion y el ocupante con su clave y su respectivo elemento; corroboro si esa posicion se encuentra ocupada. Si la posicion no esta ocupada inserto el elemento en dicha posicion y la marco como ocupada. En caso de que esa posicion si este ocupada, si no es la ultima posicion de la tabla de hash vuelvo a llamar a la misma funcion pasandole los mismos datos con la diferencia de que le paso la posicion siguiente porque aplico PROBING LINEAL. Si la posicion actual es la ultima posicion de la tabla de hash, debo volver a llamar a la funcion pero pasarle la posicion inicial como posicion actual. Una vez terminado el proceso de reinsercion, salgo de la funcion devolviendo la nueva tabla con todos los elementos insertados y con una capacidad del doble de la actual. Una vez que salgo de esa funcion guarfo el valor obtenido en una tabla auxilar previniendo el caso de que falle. Verifico si esa tabla auxiliar es nula, si lo es salgo de la funcion returneando un valor predeterminado como error. Si dicha tabla auxiliar no es nula, libero la memoria reservada previamente para la tabla actual de mi hash y en su lugar coloco esta nueva tabla y actualizo la capacidad de la tabla al doble del valor actual. Luego continuo con la insercion del elemento deseado por el usuario. 

Una vez que verifique si tengo que rehashear, puedo proceder a insertar el elemento que el usuario quiere insertar ya que estoy completamente seguro de que cuento con el espacio necesario para al menos almacenar esa clave dentro de mi tabla de hash. Para insertar calculo mediante la funcion de hash la posicion donde deberia ser insertado el elemento, llamo y devuelvo el valor deS una funcion recursiva que recibe el hash completo, dicha posicion y el ocupante con su clave y su respectivo elemento, por la dudas hago un checkeo de que si la cantidad de celdas ocupadas es mayor o igual a la capacidad del hash devulevo ERROR. Esto no deberia suceder nunca porque como dije anteriormente se supone que siempre voy a contar con espacio porque la funcion se encarga que no se supere el factor de carga. Luego verifico si la posicion donde deberia insertar el elemento esta ocupada. Si no esta ocupada, inserto el nuevo ocupante en dicha posicion, marco esa posicion como ocupada, incremento en 1 la cantidad de celdas ocupadas y salgo de la funcion returneando el valor que indica que la funcion resulto exitosa. En caso de que esa posicion este ocupada existen 3 casos que debo contemplar:

1. El elemento que esta ocupando esa posicion tiene la misma clave que el que quiero insertar. En este caso debo remplazar el elemento que tenia almacenado con el nuevo. Para ello, debo destruir, en caso de ser necesario, el elemento que tenia antes, luego le otorgo el nuevo elemento y por ultimo salgo de la funcion el valor que indica que la funcion resulto exitosa.

2. La posicion en la que me encuentro es la ultima posicion de la tabla de hash. En este caso debo seguir recorriendo la tabla de hash continuando por el inicio de la misma, para ello vuelvo a llamar a la funcion pasandole los mismos valores con la diferencia de que ahora le paso la posicion inicial como la posicion actual.

3. La posicion actual no es el final. En este caso debo seguir recorriendo realizando el PROBING LINEAL, es decir que decbo seguir recorriendo de a una posicion hasta encontrar una posicion vacia. Por lo tanto, vuelvo a llamar a la funcion pasandole los mismos paramentros con la diferencia que le voy a pasar la posicion siguiente como posicion actual.



+Hash_quitar-----> En esta funcion primero me encarco de verificar que recibo un hash y una clave valida, en este caso hash y clave no nulas. Luego calculo en que posicion deberia haber sido insertado la clave que estoy buscando por medio de la funcion de hash y la modularizacion de la misma. Una vez que obtengo dicha posicion busco el elemento linealmente, es decir que va a verificar si en esa posicion que le otorgo se encuentra el elemento, si esta me devuelve su informacion y si no se encuentra en esa posicion  ira avanzando de a una posicion hasta encontrar la clave solicitada o hasta encontrar un espacio vacio. Se podria decir que la primer parte de hash_quitar funciona de la misma forma que funciona hash_obtener. luego de buscar el elemento verifico que la funcion lo haya encontrado. Se que la funcion (buscar_elemento_linealmente) encontro el elemento si me devuelve algo no nulo, en caso de que me devuelva algo nulo salgo de la funcion returneando un  valor predeterminado como error. En el caso de haber encontrado el elemento que quiero eliminar, destruyo su informacion, vacio la celda donde se encuentra dicha clave, disminuyo la cantidaad de elementos en la tabla y procedo a buscar un elemento que pueda tomar el lugar del elemento insertado. Para ello llamo y devulevo el valor que me otorga una funcion recursiva que se encarga de buscar dicho sucesor. Esta funcion lo que hara es, si la posicion actual es la ultima posicion, reiniciara la posicion, es decir que posicion ahora tendra el valor de la posicion inicial; en el cualquier otro caso incrementara en 1 a la posicion actual. Luego verificara si la posicion se encuentra ocupada. Si no esta ocupada la funcion saldra returneando un valor predeterminado como exitoso ya que quiere decir que ningun elemento colisiono con el elemento eliminado. En el caso de estar ocupada calculara la posicion donde el elemento actual deberia haber sido insertado(posicion real). Si la posicion real es igual a la posicion actual saldra de la funcion returneando exito. Si la posicion real es distinta de la posicion actual, guardara la informacion de el ocupante de dicha celda, vaciara la celda y reinsertara el elemento en la tabla de hash. Luego de reinsertar el elemento se llamara recursivamente y devolvera su valor.   



+Hash_obtener-----> En esta funcion lo primero que hago es verificar si recibo un hash, o clave valida, en caso de no recibir una de las dos validas salgo de la funcion returneando un vaor predeterminado como erroneo. En caso de que reciba ambas validas, calcula la posicion donde la clave deberia haber sido insertada, mediante la funcion de hash y la modularizacion del resultado devuelto por la misma, y por ultimo devulevo el valor que returnea una funcion recursiva ("buscar_elemento_linealmente") que se encarga de encontrar dicho elemento. A esa funcion le voy a pasar la tabla del hash, la clave que busco, la posicion donde deberia estar insertado el elemento y la capacidad de la tabla de hash. Esta funcion lo que va a hacer es verificar si la posicion recibida es mayor a la capacidad de la tabla. Una vez verificado eso, verifico si hay o no un elemento en dicha posicion. Si no hay un elemento en la posicion donde me encuentro quiere decir que el elemento no se encuentra en la tabla de hash, por lo tanto salgo de la funcion devolviendo NULL. En el caso donde la posicion si se encuentre ocupada tengo dos casos:

caso_1. La clave del elemento que ocupa esa posicion es la misma que la del elemento que busco, es decir que el elemento que busco se encuentra en esa posicion. Si esto sucede salgo de la funcion returneando el elemento que esta vinculado con la clave de esa posicion.

caso_2. La posicion esta ocupada pero la clave de dicha posicion no es la misma que la clave del elemento que busco. En este caso tengo que volver a llamar a la misma funcion y devolver el valor que returneara, pero esta vez pasandole como posicion actual la posicion siguiente debido a que el metodo de insercion que adopte es el de Probing lineal por lo tanto esta funcion lo que hara es buscar posicion por posicion hasta encontrar la clave solicitada o un espacio vacio. 



+Hash_contiene-----> Esta funcion lo que hara sera delegarle toda la responsabilidad al buen funcionamiento de la funcion "hash_obtener". Hago esto porque las dos funciones tienen una tarea muuy similar, ambas tienen que encontrar un elemento pero lo que las diferencia es que una devuleve el elemento y la otra solo devuelve un valor booleano para indicar si se encuentra o no. Por lo tanto, llamo a has obtener pasandole el hash y la clave recibida y como se que hash obtener si encuentra el elemento devuleve dicho elemento y si no lo encuentra devuelve NULL, lo unico que debo verificar es si el resultado de la funcion hash_obtener es NULL o no. En el caso de que sea NULL slgo de la funcion devolviendo false, es decir indicando que el hash no contiene dicho elemento. En el caso que el resultado obtenido de hash_obtener no sea NULL salgo de la funcion pero esta vez devolviendo true, es decir indicando que el elemento buscado por el usuario si se encuentra en la tabla de hash.



+Hash_cantidad-----> Esta funcion lo que hara es devolver la cantidad de elementos insertados en la tabla de hash. Por como tengo armada mi estructura solo tengo que verificar si el hash recibido es valido y en caso de serlo devuelvo la cantidad de celdas ocupadas que indica en mi hash. En caso de que sea nulo el hash recibido, salgo de la funcion devolviendo cero que seria para este caso un resultado de la funcion erroneo. 



+Hash_destruir-----> En esta funcion lo que hago es primero que nada verificar si recibo una tabla valida, en caso de no ser asi salgo de  la funcion returneando un valor predeterminado como error. En caso de recibir una tabla valida, llamo a una funcion que libera la tabla de hash del mismo. Esa funcion que que hace es una iteracion que recorre cada celda de la tabla desde la ultima posicion hasta la posicion inicial. Si en esa celda donde se encuentra actualmente hay un elemento, es decir que esta ocupada, le aplicara la funcion de destruccion proveida por el usuario. Hara eso con cada una de las celdas que esten ocupadas hasta llegar a la primera. Una vez que termina de recorrer la tabla de hash libera dicha tabla y sale de la funcion. Una vez liberado la tabla y toda su informacion, libero la memoria reservada para toda mi estructura de hash.


+Hash_con_cada_clave----> En esta funcion comienzo verificando si recibi un hash o una funcion valida. En caso de no haber recibido una de estas dos en condiciones validas, es decir que recibi NULL en alguna de las dos o en las dos, salgo de la funcion returneando un valor predeterminado como error. En caso contrario, creo una iteracion que no terminada de iterar hasta que la cantidad de iteraciones no supere la capacidad de la tabla o hasta que la funcion que recibo por parte del usuario sea true. Mientras esto suceda, recorrere cada una de las celdas de mi tabla de hash y en las celdas que esten ocupadas llamare a la funcion dada por el usuario. Mientras esta funcion me devuelva valores false, seguire iterando. Cuando me devuleva true saldre de la iteracion y returneare la cantidad de veces que llame a dicha funcion.




PREGUNTAS TEORICAS:
------------------
------------------

1)¿Que es una tabla de hash?

Una tabla de hash es una estructura que contiene valores a los cuales puedo acceder mediante una clave. Cada valor esta relacionado con una sola clave, no es posible que hayan dos claves iguales. Mediante la clave, por medio de la funcion de hash, genero un valor numerico el cual indicara la posicion de la tabla donde deberia encontrarse dicho elemento. La funcion de hash es una funcion que otorga, por medio de una clave, un valor numerico y a ese valor numerico se le aplica una funcion modulo que lo que hace es devolver un valor final, que seria la pósicion dentro de la tabla, que se encontrara en un rango menor o igual a la capacidad de la tabla de hash. Como dije anteriormente, no pueden haber dos claves identicas pero si dos claves diferentes pueden dirigirme a la misma posicion de la tabla, es decir que cuando envio la clave a la funcion de hash, ésta me puede devolver el mismo numero que otra clave totalmente diferente. Cuando esto sucede se dice que hay una colision. Una tabla de hash ideal seria una tabla cuya funcion de hash devuleve valores tales que no genera colision alguna, sin embargo esto es practicamente imposible. ¿Por que digo que una tabla perfecta seria una tabla sin colisiones? porque si no hay colisiones cada operacion del hash seria de una complegidad algoritmica O(1), que es a lo que apunta una tabla de hash. Como dije que hacer una tabla de hash sin colisiones es imposible, en determinado momento del proceso hay que rehashear para que la cantidad de colisiones disminuya. Rehashear se le llama a agrandar el tamaño de la tabla de hash en una determinada cantidad y reinsertar cada una de las claves con sus respectivos elementos, es decir que cada una de las claves posiblemente se vaya a encontrar en un lugar diferente debido a que la funcion de hash otorgara valores dentro de un rango de posiciones mas amplio. 

Existen dos tipos de hash:

1. Hash abierto: El hash abierto es un tipo de hash el cual se dice que tiene un direccionamiento cerrado. Se dice que es un direccionamiento cerrado porque la cantidad de direcciones esta acotada, es decir, no puedo acceder a otras direcciones salvo esas; entonces si exite una o varias colisiones se sabe que todas ellas van a estar encerrados en una misma direccion. Dicho hash consta de una tabla de hash que cada posicion direcciona a una lista de claves con sus respectivos elementos, es decir que en cada lista van a estar contenidas todas las colisiones de un mismo valor obtenido por la funcion de hash. Lo ideal de este tipo de hash es que dichas listas tengan una longitud de un valor pequeño, dicho valor "pequeño" depende del problema en especifico ya que puede ser que para determinado problema una lista pequeña sea de 20 elementos y para otro sea de 4 elementos. La longitud de las listas tiene que ser chica debido a que si una lista es grande pierde el sentido de la implementacion del hash ya que no cumpliria con una complejidad algoritmica constante sino que adoptaria la complejidad de una lista que es lineal. Cada operacion de dicho hash se comporta igual que la misma en una lista enlazada.
 Una vez que una de las listas supera la capacidad maxima de elementos, es decir que se llego a la capacidad maxima de colisiones dentro de una direcion de la tabla, se debe rehashear.

 

2. Hash cerrado: El hash cerrado es un tipo de hash el cual se dice que tiene un direcionamiento abierto. Se dice que tiene un direccionamiento abierto porque si bien la cantidad de direciones es acotada, a la hora de insertar y que haya una colision, no se sabe si el elemento esta en el lugar donde corresponde ya que si hay colision el elemento es insertado en otra posicion la cual dependera de la implementaion individual del programador, por lo tanto no siempre basta con buscar el elemento en esa posicion sino que a veces hay que recorrer la tabla y justamente por eso se le denomina abierto debido a que si bien hay una cantidad reducida de direcciones el elemento puede estar en otra.
En este hash todos los valores se guardan dentro de una misma tabla donde el tamaño de la tabla debe ser mayor o igual a la cantidad de claves almacenadas. En caso de que la funcion de hash devuelva el mismo valor que otra clave ya almacenada, osea que la posicion en donde se debe insertar es la misma que la de un elemento ya insertado, es decir que se genera una colision, se puede proceder de infinitas maneras, pero existen 3 tipos que son los mas conocidos y aplicados:

+ "PROBING LINEAL"---> Si al momento de la insercion se genera una colision el elemento se insertara en el siguiente espacio libre disponible. Por ejemplo, si quiero insertar una clave en una tabla de hash con 4 posiciones y la funcion de hash me devuleve 2 como posicion donde deberia insertarla, y a su vez previamente habia insertado un elemento en esa posicion, es decir que se genera una colision, debo ir avanzando de a un casillero hasta encontrar un espacio libre donde insertarlo. En el caso de llegar hasta la ultima posicion y que esta este ocupada, debo continuar recorriedo pero desde el inicio de la tabla.

+ "PROBING CUADRATICO"----> Este metodo consiste en una formula que se aplica una vez que hay colisiones que son los intentos fallidos elevados al cuadrado.

+"HASH DOBLE" -----> Este metodo consiste que si se genera una colision se aplica una segunda funcion de hash al resultado obtenido. 

A la hora de insertar no es un problema el no poder insertar el elemento, debido a que se prevee mediante el rehasheo de la tabla que siempre haya al menos un lugar disponible para insertar un nuevo elemento.
Para buscar un elemento, en un caso ideal en el que no hubo colisiones, solo basta que con la clave que me piden eliminar calcule el valor de la posicion donde se deberia encontrar, mediante la funcion de hash; me dirija a esa posicion y alli estara. En un caso no ideal, es decir que hubo 1 o mas colisiones, no solo basta con dirijirme a la posicion que me indica la funcion de hash, sino que probablemente tenga que buscarlo aplicando el mismo metodo que utilice para insertarlo, es decir, probing lineal cuadratico o hash doble. Por lo tanto, si quiero buscar una determinada clave, obtengo la posicion mediante la funcion de hash, me dirijo a esa posicion y verifico si es esa la clave que busco, en caso de serla la devuelvo, en caso contrario debo recorrer la tabla aplicando el mismo metodo con el que inserte.

Para eliminar una clave con su respectivo elemento de este hash, primero debo buscar el elemento de la forma dicha anteriormente y una vez que lo encontre tengo dos formas de proceder:

+ Puedo utilizar un flag, determinado por el programador, que indique que en dicha posicion previamente hubo un elemento pero fue eliminado. Podria ser un bool, int o cualquier cosa.

+ La segunda opcion es, una vez que encontre el elemento lo elimino y a partir de esa posicion  avanzo hasta encontrar el proximo espacio vacio o una clave que pueda ser reinsertada en esa posicion. Si llego a encontrar una posicion que pueda ser movida a esa posicion donde elimine el elemento debo mover el elemento, eliminarlo de donde se encontraba anteriormente y luego vuelvo a realizar el mismo procedimiento, es decir que a partir de la posicion de donde saque ese elemento que ahora se encunetra en la posicion del anterior debo buscar un espacio vacio o un elemento que pueda ser reinsertado en esa posicion. Cabe tener en cuenta que cuando lo encuentro no debo insertarlo directamente en la posicion donde elimine el anterior, sino que vuelvo a calcular la posicion con la funcion de hash y implemento el metodo de insercion determinado, es decir que elimino el elemento en la posicion de donde estaba y lo vuelvo a insertar.

Es fundamental proceder con cualquiera de estos dos elementos a la hora de eliminar porque si ocurre que el elemento que elimine tenia colisiones, cuando quiera buscar una clave que me direccione a esa posicion no la va a encontrar porque habria un espacio vacio entonces el programa supone que no hubo colision alguna.